const THREE = require("three-full/builds/Three.cjs.js");

const Box3 = THREE.Box3;
const Vector3 = THREE.Vector3;

/**
 *  @param {Vector3} v The cone origin
 *  @param {Vector3} axis The axis, normalized.
 *  @param {number} theta The cone angle
 *  @param {number} sup The maximum distance from v in the axis direction (truncated cone). If null or undefined, will be +infinity
 *  @param {number} inf The minimum distance from v in the axis direction (truncated cone). if null or undefined, will be 0
 */
function Cone( v, axis, theta, inf, sup ) {

	this.v = v || new THREE.Vector3();
    this.axis = axis  || new THREE.Vector3(1,0,0);
    this.theta = theta;
    this.inf = inf || 0;
    this.sup = sup || +Infinity;

    this.cosTheta = Math.cos(theta);
}

Object.assign( Cone.prototype, {

	set: function ( v, axis, theta, inf, sup ) {

		this.v.copy( v );
		this.axis.copy( axis );
        this.theta = theta;
        this.inf = inf || 0;
        this.sup = sup || +Infinity;

        this.cosTheta = Math.cos(theta);

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( cone ) {

		this.v.copy( cone.v );
		this.axis.copy( cone.axis );
        this.theta = cone.theta;
        this.inf = cone.inf;
        this.sup = cone.sup;

        this.cosTheta = Math.cos(this.theta);

		return this;

	},

	empty: function () {

		return ( this.theta <= 0 || this.inf >= this.sup );

	},

	getBoundingBox: function ( target ) {

		throw "not implemented yet, todo";

		return target;

	},

	equals: function ( cone ) {

		return cone.v.equals(this.v) && cone.axis.equals(this.axis) && cone.theta === this.theta && cone.inf === this.inf && cone.sup === this.sup;

	}

} );


/**
 *
 * Compute intersections of a ray with a cone.
 * For more on this algorithm : http://www.geometrictools.com/Documentation/IntersectionLineCone.pdf
 *
 * @param {!Cone} cone is a truncated cone and must must define :
 *      v the singular point
 *      axis the cone direction
 *      inf >= 0 all points P such that Dot(axis,P-v) < inf are not considered in the cone
 *      sup > 0 all points P such that Dot(axis,P-v) > sup are not considered in the cone
 *
 * @return {number} The number of intersections and fill res with :
 * @param {!Object} start Ray starting point
 * @param {!Object} dir Ray direction >> Edit seems it needs to be normalized
 * @param {!Object} res Resulting intersections in :
 *      res.inter_t     array containing 0,1 or 2 scalar t such that start + t*dir are intersection points. I'm not sure if any assumption can be made on the order of thoses values.
 *      res.inter_p     points of intersection
 *      res.inter_dot   values such that <(inter_p - cone.v) | cone.axis> = inter_dot
 *
 */
THREE.Ray.prototype.intersectCone = (function()
{
    // static variables for the function
    var E = new THREE.Vector3();

    return function(cone, start, dir, res)
    {
        // Set up the quadratic Q(t) = c2*t^2 + 2*c1*t + c0 that corresponds to
        // the cone.  Let the vertex be V, the unit-length direction vector be A,
        // and the angle measured from the cone axis to the cone wall be Theta,
        // and define g = cos(Theta).  A point X is on the cone wall whenever
        // Dot(A,(X-V)/|X-V|) = g.  Square this equation and factor to obtain
        //   (X-V)^T * (A*A^T - g^2*I) * (X-V) = 0
        // where the superscript T denotes the transpose operator.  This defines
        // a double-sided cone.  The line is L(t) = P + t*D, where P is the line
        // origin and D is a unit-length direction vector.  Substituting
        // X = L(t) into the cone equation above leads to Q(t) = 0.  Since we
        // want only intersection points on the single-sided cone that lives in
        // the half-space pointed to by A, any point L(t) generated by a root of
        // Q(t) = 0 must be tested for Dot(A,L(t)-V) >= 0.

        var cos_angle = cone.cosTheta;
        var AdD = cone.axis.dot(dir);
        var cos_sqr = cos_angle*cos_angle;
        E.subVectors(start,cone.v);
        var AdE = cone.axis.dot(E);
        var DdE = dir.dot(E);
        var EdE = E.dot(E);
        var c2 = AdD*AdD - cos_sqr;
        var c1 = AdD*AdE - cos_sqr*DdE;
        var c0 = AdE*AdE - cos_sqr*EdE;
        var dot;

        res.inter_p = {};
        res.inter_t = {};
        res.inter_dot = {};

        // Solve the quadratic.  Keep only those X for which Dot(A,X-V) >= 0.
        if (Math.abs(c2) >= 0)
        {
            // c2 != 0
            var discr = c1*c1 - c0*c2;
            if (discr < 0)
            {
                // Q(t) = 0 has no real-valued roots.  The line does not
                // intersect the double-sided cone.
                return 0;
            }
            else if (discr > 0)
            {
                // Q(t) = 0 has two distinct real-valued roots.  However, one or
                // both of them might intersect the portion of the double-sided
                // cone "behind" the vertex.  We are interested only in those
                // intersections "in front" of the vertex.
                var root = Math.sqrt(discr);
                var invC2 = 1/c2;
                var quantity = 0;

                var t = (-c1 - root)*invC2;
                res.inter_t[quantity] = t;
                res.inter_p[quantity] = new THREE.Vector3(start.x + t*dir.x,
                                                          start.y + t*dir.y,
                                                          start.z + t*dir.z);
                E.subVectors(res.inter_p[quantity],cone.v);
                dot = E.dot(cone.axis);
                if (dot > cone.inf && dot < cone.sup)
                {
                    res.inter_dot[quantity] = dot;
                    quantity++;
                }

                t = (-c1 + root)*invC2;
                res.inter_t[quantity] = t;
                res.inter_p[quantity] = new THREE.Vector3(start.x + t*dir.x,
                                                          start.y + t*dir.y,
                                                          start.z + t*dir.z);
                E.subVectors(res.inter_p[quantity],cone.v);
                dot = E.dot(cone.axis);
                if (dot>cone.inf && dot<cone.sup)
                {
                    res.inter_dot[quantity] = dot;
                    quantity++;
                }

                if (quantity == 2)
                {
                    // The line intersects the single-sided cone in front of the
                    // vertex twice.
                    return 2;
                }
                else if (quantity == 1)
                {
                    // The line intersects the single-sided cone in front of the
                    // vertex once.  The other intersection is with the
                    // single-sided cone behind the vertex.
                    return 1;
                }
                else
                {
                    // The line intersects the single-sided cone behind the vertex
                    // twice.
                    return 0;
                }
            }
            else
            {
                // One repeated real root (line is tangent to the cone).
                res.inter_t[0] = c1/c2;
                res.inter_p[0] = new THREE.Vector3( start.x - res.inter_t[0]*dir.x,
                                                    start.y - res.inter_t[0]*dir.y,
                                                    start.z - res.inter_t[0]*dir.z);
                E.subVectors(res.inter_p[0],cone.v);
                dot = E.dot(cone.axis);
                if ( dot > cone.inf && dot < cone.sup)
                {
                    res.inter_dot[0] = dot;
                    return 1;
                }
                else
                {
                    return 0;
                }
            }
        }
        else if (Math.abs(c1) >= 0)
        {
            // c2 = 0, c1 != 0 (D is a direction vector on the cone boundary)

            res.inter_t[0] = 0.5*c0/c1;
            res.inter_p[0] = new THREE.Vector3( start.x - res.inter_t[0]*dir.x,
                                                start.y - res.inter_t[0]*dir.y,
                                                start.z - res.inter_t[0]*dir.z);
            E.subVectors(res.inter_p[0],cone.v);
            dot = E.dot(cone.axis);
            if (dot > cone.inf && dot < cone.sup)
            {
                res.inter_dot[0] = dot;
                return 1;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            // c2 = c1 = 0, c0 != 0
            // OR
            // c2 = c1 = c0 = 0, cone contains ray V+t*D where V is cone vertex
            // and D is the line direction.
            return 0;
        }
    };
})();

export { Cone };
