!(function(t, s) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = s(require("three-full/builds/Three.cjs.js")))
: "function" == typeof define && define.amd
? define(["three-full/builds/Three.cjs.js"], s)
: (t.THREECone = s(t.THREE));
})(this, function(t) {
"use strict";
(t = t && t.hasOwnProperty("default") ? t.default : t).Box3, t.Vector3;
function s(s, i, e, n, o) {
(this.v = s || new t.Vector3()),
(this.axis = i || new t.Vector3(1, 0, 0)),
(this.theta = e),
(this.inf = n || 0),
(this.sup = o || 1 / 0),
(this.cosTheta = Math.cos(e));
}
var i;
return (
Object.assign(s.prototype, {
set: function(t, s, i, e, n) {
return (
this.v.copy(t),
this.axis.copy(s),
(this.theta = i),
(this.inf = e || 0),
(this.sup = n || 1 / 0),
(this.cosTheta = Math.cos(i)),
this
);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(t) {
return (
this.v.copy(t.v),
this.axis.copy(t.axis),
(this.theta = t.theta),
(this.inf = t.inf),
(this.sup = t.sup),
(this.cosTheta = Math.cos(this.theta)),
this
);
},
empty: function() {
return this.theta <= 0 || this.inf >= this.sup;
},
getBoundingBox: function(t) {
throw "not implemented yet, todo";
},
equals: function(t) {
return (
t.v.equals(this.v) &&
t.axis.equals(this.axis) &&
t.theta === this.theta &&
t.inf === this.inf &&
t.sup === this.sup
);
}
}),
(t.Cone = s),
(t.Ray.prototype.intersectCone = ((i = new t.Vector3()),
function(t, s) {
var e = t.cosTheta,
n = t.axis.dot(this.direction),
o = e * e;
i.subVectors(this.origin, t.v);
var h,
u = t.axis.dot(i),
r = n * n - o,
a = n * u - o * this.direction.dot(i),
c = u * u - o * i.dot(i);
if (Math.abs(r) >= 0) {
var f = a * a - c * r;
if (f < 0) return null;
if (f > 0) {
var p = Math.sqrt(f),
d = 1 / r,
l = 0,
v = (-a - p) * d;
return (
this.at(v, s),
i.subVectors(s, t.v),
(h = i.dot(t.axis)) > t.inf && h < t.sup && l++,
(v = (-a + p) * d),
this.at(v, s),
i.subVectors(s, t.v),
(h = i.dot(t.axis)) > t.inf && h < t.sup && l++,
2 == l ? s : 1 == l ? s : null
);
}
return (
(v = a / r),
this.at(v, s),
i.subVectors(s, t.v),
(h = i.dot(t.axis)) > t.inf && h < t.sup ? s : null
);
}
return Math.abs(a) >= 0
? ((v = (0.5 * c) / a),
  this.at(v, s),
  i.subVectors(s, t.v),
  (h = i.dot(t.axis)) > t.inf && h < t.sup ? s : null)
: null;
})),
s
);
});
