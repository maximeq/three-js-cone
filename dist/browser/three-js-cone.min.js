!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? e(exports)
: "function" == typeof define && define.amd
? define(["exports"], e)
: e((t.THREEDisposer = {}));
})(this, function(t) {
"use strict";
const e = require("three-full/builds/Three.cjs.js");
e.Box3, e.Vector3;
function i(t, i, s, n, r) {
(this.v = t || new e.Vector3()),
(this.axis = i || new e.Vector3(1, 0, 0)),
(this.theta = s),
(this.inf = n || 0),
(this.sup = r || 1 / 0),
(this.cosTheta = Math.cos(s));
}
var s;
Object.assign(i.prototype, {
set: function(t, e, i, s, n) {
return (
this.v.copy(t),
this.axis.copy(e),
(this.theta = i),
(this.inf = s || 0),
(this.sup = n || 1 / 0),
(this.cosTheta = Math.cos(i)),
this
);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(t) {
return (
this.v.copy(t.v),
this.axis.copy(t.axis),
(this.theta = t.theta),
(this.inf = t.inf),
(this.sup = t.sup),
(this.cosTheta = Math.cos(this.theta)),
this
);
},
empty: function() {
return this.theta <= 0 || this.inf >= this.sup;
},
getBoundingBox: function(t) {
throw "not implemented yet, todo";
},
equals: function(t) {
return (
t.v.equals(this.v) &&
t.axis.equals(this.axis) &&
t.theta === this.theta &&
t.inf === this.inf &&
t.sup === this.sup
);
}
}),
(e.Ray.prototype.intersectCone = ((s = new e.Vector3()),
function(t, i, n, r) {
var o = t.cosTheta,
h = t.axis.dot(n),
u = o * o;
s.subVectors(i, t.v);
var c,
a = t.axis.dot(s),
p = h * h - u,
f = h * a - u * n.dot(s),
_ = a * a - u * s.dot(s);
if (
((r.inter_p = {}), (r.inter_t = {}), (r.inter_dot = {}), Math.abs(p) >= 0)
) {
var d = f * f - _ * p;
if (d < 0) return 0;
if (d > 0) {
var x = Math.sqrt(d),
y = 1 / p,
v = 0,
V = (-f - x) * y;
return (
(r.inter_t[v] = V),
(r.inter_p[v] = new e.Vector3(i.x + V * n.x, i.y + V * n.y, i.z + V * n.z)),
s.subVectors(r.inter_p[v], t.v),
(c = s.dot(t.axis)) > t.inf && c < t.sup && ((r.inter_dot[v] = c), v++),
(V = (-f + x) * y),
(r.inter_t[v] = V),
(r.inter_p[v] = new e.Vector3(i.x + V * n.x, i.y + V * n.y, i.z + V * n.z)),
s.subVectors(r.inter_p[v], t.v),
(c = s.dot(t.axis)) > t.inf && c < t.sup && ((r.inter_dot[v] = c), v++),
2 == v ? 2 : 1 == v ? 1 : 0
);
}
return (
(r.inter_t[0] = f / p),
(r.inter_p[0] = new e.Vector3(
i.x - r.inter_t[0] * n.x,
i.y - r.inter_t[0] * n.y,
i.z - r.inter_t[0] * n.z
)),
s.subVectors(r.inter_p[0], t.v),
(c = s.dot(t.axis)) > t.inf && c < t.sup ? ((r.inter_dot[0] = c), 1) : 0
);
}
return Math.abs(f) >= 0
? ((r.inter_t[0] = (0.5 * _) / f),
  (r.inter_p[0] = new e.Vector3(
  i.x - r.inter_t[0] * n.x,
  i.y - r.inter_t[0] * n.y,
  i.z - r.inter_t[0] * n.z
  )),
  s.subVectors(r.inter_p[0], t.v),
  (c = s.dot(t.axis)) > t.inf && c < t.sup ? ((r.inter_dot[0] = c), 1) : 0)
: 0;
})),
(t.Cone = i),
Object.defineProperty(t, "__esModule", {value: !0});
});
