!(function(t, s) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = s(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], s)
: (t.THREECone = s(t.THREE));
})(this, function(t) {
"use strict";
(t = t && t.hasOwnProperty("default") ? t.default : t).Box3, t.Vector3;
function s(s, i, e, n, o) {
(this.v = s || new t.Vector3()),
(this.axis = i || new t.Vector3(1, 0, 0)),
(this.theta = e),
(this.inf = n || 0),
(this.sup = o || 1 / 0),
(this.cosTheta = Math.cos(e));
}
var i, e;
return (
Object.assign(s.prototype, {
set: function(t, s, i, e, n) {
return (
this.v.copy(t),
this.axis.copy(s),
(this.theta = i),
(this.inf = e || 0),
(this.sup = n || 1 / 0),
(this.cosTheta = Math.cos(i)),
this
);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(t) {
return (
this.v.copy(t.v),
this.axis.copy(t.axis),
(this.theta = t.theta),
(this.inf = t.inf),
(this.sup = t.sup),
(this.cosTheta = Math.cos(this.theta)),
this
);
},
empty: function() {
return this.theta <= 0 || this.inf >= this.sup;
},
getBoundingBox: function(t) {
throw "not implemented yet, todo";
},
equals: function(t) {
return (
t.v.equals(this.v) &&
t.axis.equals(this.axis) &&
t.theta === this.theta &&
t.inf === this.inf &&
t.sup === this.sup
);
}
}),
(t.Cone = s),
(t.Ray.prototype.intersectCone =
((i = new t.Vector3()),
(e = new t.Vector3()),
function(t, s) {
var n = t.cosTheta,
o = t.axis.dot(this.direction),
h = n * n;
i.subVectors(this.origin, t.v);
var r,
u = t.axis.dot(i),
a = o * o - h,
c = o * u - h * this.direction.dot(i),
f = u * u - h * i.dot(i);
if (Math.abs(a) >= 0) {
var p = c * c - f * a;
if (p < 0) return null;
if (p > 0) {
var d = Math.sqrt(p),
l = 1 / a,
v = 0;
(y = (-c - d) * l) > 0 &&
(this.at(y, s),
i.subVectors(s, t.v),
(r = i.dot(t.axis)) > t.inf && r < t.sup && v++);
var x = (-c + d) * l;
return (
x > 0 &&
x < y &&
(this.at(x, e),
i.subVectors(e, t.v),
(r = i.dot(t.axis)) > t.inf && r < t.sup && (v++, s.copy(e))),
2 == v ? s : 1 == v ? s : null
);
}
var y = c / a;
return (
this.at(y, s),
i.subVectors(s, t.v),
(r = i.dot(t.axis)) > t.inf && r < t.sup ? s : null
);
}
return Math.abs(c) >= 0
? ((y = (0.5 * f) / c),
  this.at(y, s),
  i.subVectors(s, t.v),
  (r = i.dot(t.axis)) > t.inf && r < t.sup ? s : null)
: null;
})),
s
);
});
